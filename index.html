<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexudus Internal Update Tool</title>
    <link rel="icon" href="https://nexudusacademy.spaces.nexudus.com//images/Favicon.jpg">
    <!-- Luxon library for timezone handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.4.4/luxon.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600&family=Poppins:wght@400;600&display=swap');
        
        body { 
            font-family: 'Poppins', sans-serif; 
            padding: 20px; 
            background-color: #f8f8f8; 
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            background-color: white; 
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); 
        }
        h1, h3 { 
            font-family: 'Playfair Display', serif;
            font-weight: 600;
            color: #001279; 
        }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        h3 { font-size: 1.25rem; margin-top: 2rem; margin-bottom: 0.75rem; }
        p { color: #4b5563; line-height: 1.5; }
        .warning-text {
            color: #732031;
            font-weight: 600;
            font-style: italic;
            margin-bottom: 20px;
        }
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-sizing: border-box;
            transition: all 0.2s ease;
            height: 40px; /* Consistent height */
        }
        input[type="text"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: #001279;
            box-shadow: 0 0 0 3px #16289B;
        }
        input[type="file"] {
            display: block;
            margin-top: 10px;
        }
        button {
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
            height: 40px; /* Consistent height */
            box-sizing: border-box;
        }
        select {
            height: 40px; /* Consistent height */
            padding: 8px 10px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-sizing: border-box;
            width: 100%;
        }
        #startButton {
            background-color: #FF5100;
        }
        #startButton:hover {
            background-color: #BF3700;
        }
        #authButton {
            background-color: #001279;
        }
        #authButton:hover {
            background-color: #16289B;
        }
        #downloadButton {
            display: none;
            margin-top: 15px;
            background-color: #001279;
        }
        #downloadButton:hover {
            background-color: #16289B;
        }
        #stopButton {
            display: none;
            margin-left: 10px;
            background-color: #BF3700;
        }
        #stopButton:hover {
            background-color: #FF5100;
        }
        #proceedButton {
            display: none;
            margin-left: 10px;
            background-color: #001279;
        }
        #proceedButton:hover {
            background-color: #16289B;
        }
        #log {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: scroll;
            margin-top: 20px;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #374151;
        }
        .log-success { color: #10b981; }
        .log-error { color: #940a0a; }
        .log-info { color: #001279; }
        .logo-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .logo {
            max-width: 250px;
            height: auto;
        }
        .collapsible-content {
            display: none;
            padding: 15px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background-color: #f9fafb;
            margin-top: 10px;
        }
        #toggleGuideButton {
            background-color: #4b5563;
            color: white;
            height: 40px;
            padding: 8px 15px;
        }
        #toggleGuideButton:hover {
            background-color: #374151;
        }
        #customEndpointInput {
            display: none;
        }
        .endpoint-text {
            color: #6b7280;
            font-size: 0.875rem;
        }
        .light-text {
            color: #a0a0a0;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .input-group select {
            flex-grow: 1;
            margin-bottom: 0;
            width: auto;
            min-width: 0;
        }
        .input-group button {
            white-space: nowrap;
            padding: 10px 15px;
            margin-top: 0;
            flex-shrink: 0;
        }
        #getTemplateButton {
            background-color: #001279;
        }
        #getTemplateButton:hover {
            background-color: #16289B;
        }
        .form-group-inline {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #authButton {
            margin-top: 15px;
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="logo-container">
            <img src="https://nexudusacademy.spaces.nexudus.com//images/Logo.png?cache=2025-08-08T11:13:58+04:00" alt="Nexudus Logo" class="logo">
        </div>
        <h1>Nexudus Internal Update Tool</h1>
        <p class="warning-text"><i>Please only use this tool if you're confident in doing so. Making changes without full confidence can cause irreversible changes.</i></p>

        <p>This tool reads a CSV file, iterates through each row, and sends a custom API request. Failed updates will be logged and can be exported to a new file at the end.</p>

        <!-- Guide Section -->
        <button id="toggleGuideButton" onclick="toggleGuide()">Show Guide</button>
        <div id="updateGuide" class="collapsible-content">
            <h4>How to Use This Tool:</h4>
            <p>This tool can currently be used for Updating and Creating records.</p>
            <br>
            <h5>Update:</h5>
            <ol>
                <li><b>Export the existing records:</b> From the Nexudus Admin Panel, export the current records. This file is crucial because it contains the <b>`Id`</b> field, which tells the tool exactly which records to update.</li>
                <li><b>Prepare your file:</b> Clean the export file by removing any columns you will not be updating. You only need to keep the `Id` and the columns with the new data.</li>
                <li><b>Add updated data:</b> Add the column headers for the fields you want to change. For example, if you need to update the `BillingDay` for a list of Contracts, your CSV should include a `BillingDay` column. You can find all possible column headers in the Nexudus API documentation at `developers.nexudus.com`.</li>
                <li><b>Format data correctly:</b>
                    <ul>
                        <li><b>Lists of items</b> will be correctly processed as a JSON array, but only if they are separated by a <b>semicolon (;)</b>. Do not use a comma to separate lists! For example, `Desks: Desk1;Desk2`.</li>
                        <li><b>Dates</b> should be formatted in UTC as `yyyy-mm-dd hh:mm`. The tool will handle the conversion to the correct API format.</li>
                    </ul>
                </li>
            </ol>
            <br>
            <h5>Create:</h5>
            <p>The process for creating new records is the same as above, but you <b>do not need to include the `Id`</b> in your CSV. Ensure all other fields are completed.</p>
            <br>
            <h5>Get (New!):</h5>
            <p>To retrieve full record details, select the `GET` method. Your CSV file should contain only a single column named `Id` with the IDs of the records you wish to retrieve. The tool will download a new CSV with the full details of all successful requests.</p>
        </div>

        <!-- Authentication Section -->
        <h3>1. Authentication</h3>
        <p>Choose your authentication method and enter your credentials. This information is not stored.</p>
        <div class="form-group-inline">
            <label for="authMethod">Auth Method:</label>
            <input type="radio" id="authMethodBasic" name="authMethod" value="basic" checked onchange="toggleAuthFields()">
            <label for="authMethodBasic">Basic Auth</label>
            <input type="radio" id="authMethodOAuth" name="authMethod" value="oauth2" onchange="toggleAuthFields()">
            <label for="authMethodOAuth">OAuth2</label>
        </div>
        <div id="basicAuthFields">
            <label for="username" class="font-medium text-gray-700">Username:</label>
            <input type="text" id="username" oninput="checkAuthButtonValidity()">
            <label for="password" class="font-medium text-gray-700">Password:</label>
            <input type="password" id="password" oninput="checkAuthButtonValidity()">
        </div>
        <div id="oauth2AuthFields" style="display: none;">
            <label for="oauth2Token" class="font-medium text-gray-700">OAuth2 Access Token:</label>
            <input type="password" id="oauth2Token" oninput="checkAuthButtonValidity()">
        </div>
        <button id="authButton" onclick="testAuth()" disabled>Test Authentication</button>

        <div id="step2and3" style="display:none;">
            <!-- API Configuration Section -->
            <h3>2. API Configuration</h3>
            <p>Specify the API endpoint and the HTTP method to use for the requests. For PUT requests, the tool will automatically detect array fields from a sample record.</p>
            <div class="input-group">
                <label for="recordType" class="font-medium text-gray-700">Record Type:</label>
                <select id="recordType" onchange="handleRecordTypeChange()">
                    <option value="">-- Select a record type --</option>
                    <option value="https://spaces.nexudus.com/api/spaces/bookings">Bookings</option>
                    <option value="https://spaces.nexudus.com/api/spaces/bookingproducts">Booking Products</option>
                    <option value="https://spaces.nexudus.com/api/spaces/bookingvisitors">Booking Visitors</option>
                    <option value="https://spaces.nexudus.com/api/billing/contractcontacts">Contract Contact - Virtual Offices</option>
                    <option value="https://spaces.nexudus.com/api/billing/contractdeposits">Contract Deposit</option>
                    <option value="https://spaces.nexudus.com/api/billing/contractproducts">Contract Products</option>
                    <option value="https://spaces.nexudus.com/api/billing/contractschedules">Contract Schedules</option>
                    <option value="https://spaces.nexudus.com/api/billing/coworkercontracts">Contracts</option>
                    <option value="https://spaces.nexudus.com/api/billing/coworkerdiscountcodes">Customer Discount Code</option>
                    <option value="https://spaces.nexudus.com/api/spaces/coworkerdatafiles">Customer Documents</option>
                    <option value="https://spaces.nexudus.com/api/spaces/coworkernotes">Customer Note</option>
                    <option value="https://spaces.nexudus.com/api/billing/coworkerproducts">Customer Product Sale</option>
                    <option value="https://spaces.nexudus.com/api/spaces/coworkers">Customers</option>
                    <option value="https://spaces.nexudus.com/api/spaces/coworkerdeliveries">Deliveries</option>
                    <option value="https://spaces.nexudus.com/api/content/calendarevents">Events</option>
                    <option value="https://spaces.nexudus.com/api/crm/cannedresponses">Message Macros</option>
                    <option value="https://spaces.nexudus.com/api/billing/timepasses">Pass</option>
                    <option value="https://spaces.nexudus.com/api/billing/tariffs">Plan</option>
                    <option value="https://spaces.nexudus.com/api/billing/products">Product</option>
                    <option value="custom">None of these? Enter a custom API endpoint URL</option>
                </select>
                <button id="getTemplateButton" onclick="getTemplate()" disabled>Get CSV Template</button>
            </div>
            <div id="customEndpointInput" style="display: none;">
                <label for="apiEndpoint" class="font-medium text-gray-700">Custom API Endpoint URL:</label>
                <input type="text" id="apiEndpoint" placeholder="e.g., https://spaces.nexudus.com/api/custom" onchange="handleCustomEndpointChange()">
            </div>
            <div id="selectedEndpointDisplay">
                <span class="endpoint-text">Selected Endpoint: </span><span class="endpoint-text" id="selectedEndpointValue"></span>
            </div>
            <div class="form-group-inline">
                <label for="httpMethod" class="font-medium text-gray-700">HTTP Method:</label>
                <select id="httpMethod" onchange="checkStartButtonValidity()">
                    <option value="PUT">Update Records <span class="light-text">(PUT)</span></option>
                    <option value="POST">Create Records <span class="light-text">(POST)</span></option>
                    <option value="DELETE">Delete Records <span class="light-text">(DELETE)</span></option>
                    <option value="GET">Get Records <span class="light-text">(GET)</span></option>
                </select>
            </div>
            
            <!-- File Upload and Action Section -->
            <h3>3. Upload CSV & Run</h3>
            <p>Upload the CSV file. The tool will use the 'Id' column to identify the record and all other columns to form the update payload.</p>
            <input type="file" id="csvFile" accept=".csv">
            <br><br>
            <button id="startButton" onclick="startUpdate()" disabled>Start Process</button>
            <button id="proceedButton" style="display: none;">Proceed</button>
            <button id="stopButton" onclick="stopProcessing()" style="display: none;">Stop Processing</button>
            <button id="downloadButton" style="display: none;"></button>
        </div>

        <!-- Progress Log Section -->
        <div id="step4" style="display:none;">
            <h3>4. Progress Log</h3>
            <div id="progressBarContainer">
                <div id="progressBar"></div>
            </div>
            <p class="status-message" id="progressStatus">Ready to begin.</p>
            <pre id="log"></pre>
        </div>
    </div>

    <script>
        // Array to store failed records and successfully retrieved records
        let failedRecords = [];
        let allRecords = [];
        let fetchedRecords = [];
        const requestDelay = 1100; // 1.1 seconds delay between requests to respect rate limits
        let isProcessing = false;
        let arrayFields = []; // Dynamically discovered array fields
        let processedCount = 0;
        let authHeader = '';
        let proceedResolver = null;
        let businessTimeZoneCache = {}; // Cache for timezone data
        let isGetOperation = false;
        let isAuthenticated = false;

        // List of fields that are expected to be dates
        const dateFields = [
            'StartDate', 'RenewalDate', 'InvoicedPeriod', 'CancellationDate', 
            'PricePlanTermsAcceptedOn', 'UpdatedOn', 'CreatedOn'
        ];

        // Helper functions
        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            if (logElement) {
                const logEntry = document.createElement('span');
                logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}\n`;
                
                if (type === 'success') {
                    logEntry.className = 'log-success';
                } else if (type === 'error') {
                    logEntry.className = 'log-error';
                } else {
                    logEntry.className = 'log-info';
                }
                
                logElement.appendChild(logEntry);
                logElement.scrollTop = logElement.scrollHeight;
            }
        }

        async function setAuthHeader() {
            const authMethod = document.querySelector('input[name="authMethod"]:checked').value;
            if (authMethod === 'basic') {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                if (!username || !password) {
                    return false;
                }
                authHeader = 'Basic ' + btoa(username + ':' + password);
            } else if (authMethod === 'oauth2') {
                const oauth2Token = document.getElementById('oauth2Token').value;
                if (!oauth2Token) {
                    return false;
                }
                authHeader = 'Bearer ' + oauth2Token;
            }
            return true;
        }

        async function testAuth() {
            log('Testing authentication credentials...', 'info');
            const authButton = document.getElementById('authButton');
            authButton.disabled = true;

            const isSet = await setAuthHeader();
            if (!isSet) {
                log('Error: Please enter your credentials.', 'error');
                authButton.disabled = false;
                return;
            }

            try {
                // Use a generic, low-impact GET endpoint to test credentials
                const response = await fetch('https://spaces.nexudus.com/api/spaces/coworkers?PageSize=1', {
                    method: 'GET',
                    headers: { 'Authorization': authHeader }
                });

                if (response.ok) {
                    isAuthenticated = true;
                    log('Authentication successful! You can now proceed.', 'success');
                    document.getElementById('step2and3').style.display = 'block';
                    document.getElementById('step4').style.display = 'block';
                } else {
                    isAuthenticated = false;
                    log(`Authentication failed. Status: ${response.status}. Please check your credentials.`, 'error');
                }
            } catch (error) {
                isAuthenticated = false;
                log(`Authentication failed: ${error.message || 'Network error.'}`, 'error');
            }
            authButton.disabled = false;
            checkStartButtonValidity();
        }
        
        function checkAuthButtonValidity() {
            const authMethod = document.querySelector('input[name="authMethod"]:checked').value;
            const authButton = document.getElementById('authButton');
            let isAuthProvided = false;
            if (authMethod === 'basic') {
                const usernameInput = document.getElementById('username');
                const passwordInput = document.getElementById('password');
                isAuthProvided = usernameInput.value !== '' && passwordInput.value !== '';
            } else if (authMethod === 'oauth2') {
                const oauth2TokenInput = document.getElementById('oauth2Token');
                isAuthProvided = oauth2TokenInput.value !== '';
            }
            authButton.disabled = !isAuthProvided;
        }

        function checkStartButtonValidity() {
            const recordTypeSelect = document.getElementById('recordType');
            const customEndpointInput = document.getElementById('apiEndpoint');
            const getTemplateButton = document.getElementById('getTemplateButton');
            const startButton = document.getElementById('startButton');
            const httpMethod = document.getElementById('httpMethod').value;
            
            const isEndpointSelected = recordTypeSelect.value !== '' && recordTypeSelect.value !== 'custom';
            const isCustomEndpointEntered = recordTypeSelect.value === 'custom' && customEndpointInput.value !== '';
            const isApiReady = isEndpointSelected || isCustomEndpointEntered;
            
            if(getTemplateButton) getTemplateButton.disabled = !isAuthenticated || !isApiReady;
            if(startButton) startButton.disabled = !isAuthenticated || !isApiReady;
            if (startButton) {
                startButton.textContent = httpMethod === 'GET' ? 'Start Get' : 'Start Process';
            }
        }
        
        // Toggles visibility of auth fields based on radio button selection
        function toggleAuthFields() {
            const authMethod = document.querySelector('input[name="authMethod"]:checked').value;
            const basicAuthDiv = document.getElementById('basicAuthFields');
            const oauth2AuthDiv = document.getElementById('oauth2AuthFields');
            
            if (authMethod === 'basic') {
                basicAuthDiv.style.display = 'block';
                oauth2AuthDiv.style.display = 'none';
            } else if (authMethod === 'oauth2') {
                basicAuthDiv.style.display = 'none';
                oauth2AuthDiv.style.display = 'block';
            }
            checkAuthButtonValidity();
        }

        function handleRecordTypeChange() {
            const selectElement = document.getElementById('recordType');
            const customInputDiv = document.getElementById('customEndpointInput');
            const selectedEndpointValueSpan = document.getElementById('selectedEndpointValue');
            
            if (selectElement.value === 'custom') {
                if(customInputDiv) customInputDiv.style.display = 'block';
                if(selectedEndpointValueSpan) selectedEndpointValueSpan.textContent = 'Custom';
            } else if (selectElement.value === '') {
                if(customInputDiv) customInputDiv.style.display = 'none';
                if(selectedEndpointValueSpan) selectedEndpointValueSpan.textContent = '';
            } else {
                if(customInputDiv) customInputDiv.style.display = 'none';
                if(selectedEndpointValueSpan) selectedEndpointValueSpan.textContent = selectElement.value;
            }
            checkStartButtonValidity();
        }

        function handleCustomEndpointChange() {
            const customEndpointInput = document.getElementById('apiEndpoint');
            const selectedEndpointValueSpan = document.getElementById('selectedEndpointValue');

            if(selectedEndpointValueSpan) selectedEndpointValueSpan.textContent = customEndpointInput.value || 'Custom';
            checkStartButtonValidity();
        }

        function toggleGuide() {
            const guide = document.getElementById('updateGuide');
            const button = document.getElementById('toggleGuideButton');
            if (guide && button) {
                if (guide.style.display === 'block') {
                    guide.style.display = 'none';
                    button.textContent = 'Show Guide';
                } else {
                    guide.style.display = 'block';
                    button.textContent = 'Hide Guide';
                }
            }
        }

        function stopProcessing() {
            isProcessing = false;
            log('Processing stopped by user.', 'error');
            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            const proceedButton = document.getElementById('proceedButton');
            const getTemplateButton = document.getElementById('getTemplateButton');

            if (startButton) startButton.disabled = false;
            if (getTemplateButton) getTemplateButton.disabled = false;
            if (stopButton) stopButton.style.display = 'none';
            if (proceedButton) proceedButton.style.display = 'none';
            
            if (proceedResolver) {
                proceedResolver();
                proceedResolver = null;
            }
        }

        function updateProgressBar(count, total) {
            const progressBar = document.getElementById('progressBar');
            const progressStatus = document.getElementById('progressStatus');
            if (progressBar && progressStatus) {
                const percentage = (count / total) * 100;
                progressBar.style.width = `${percentage}%`;
                progressStatus.textContent = `Progress: ${count} of ${total} records processed.`;
            }
        }

        /**
         * Fetches the IANA timezone identifier for a given location.
         * @param {string} locationId - The location ID from the CSV file.
         * @returns {string|null} The IANA timezone identifier (e.g., 'America/New_York') or null on failure.
         */
        async function getBusinessTimeZoneByLocation(locationId) {
            if (businessTimeZoneCache[locationId]) {
                log(`Using cached timezone for Location ID: ${locationId}`, 'info');
                return businessTimeZoneCache[locationId];
            }

            // Updated API endpoint to use the specific locationId
            const businessApiUrl = `https://spaces.nexudus.com/api/sys/businesses/${locationId}`;
            
            try {
                const businessResponse = await fetch(businessApiUrl, {
                    method: 'GET',
                    headers: { 'Authorization': authHeader }
                });

                if (!businessResponse.ok) {
                    const errorText = await businessResponse.text();
                    throw new Error(`Failed to fetch business for Location ID ${locationId}. Status: ${businessResponse.status}. Message: ${errorText}`);
                }
                const businessData = await businessResponse.json();
                
                log(`Full Business API response for Location ID ${locationId}:\n${JSON.stringify(businessData, null, 2)}`, 'info');
                
                const simpleTimeZoneId = businessData.SimpleTimeZoneId;
                
                if (!simpleTimeZoneId) {
                    throw new Error('Could not find SimpleTimeZoneId in the business record.');
                }

                const timeZoneApiUrl = `https://spaces.nexudus.com/api/sys/simpletimezones/${simpleTimeZoneId}`;
                const timezoneResponse = await fetch(timeZoneApiUrl, {
                    method: 'GET',
                    headers: { 'Authorization': authHeader }
                });

                if (!timezoneResponse.ok) {
                    const errorText = await timezoneResponse.text();
                    throw new Error(`Failed to fetch timezone details for SimpleTimeZoneId ${simpleTimeZoneId}. Status: ${timezoneResponse.status}. Message: ${errorText}`);
                }
                const timezoneData = await timezoneResponse.json();
                
                if (!timezoneData.Iana) {
                    throw new Error('Could not find Iana identifier in timezone details.');
                }

                log(`Successfully retrieved SimpleTimeZoneId: ${simpleTimeZoneId} for Location ID: ${locationId}`, 'success');
                log(`Resolved to IANA timezone: ${timezoneData.Iana}`, 'success');
                
                businessTimeZoneCache[locationId] = timezoneData.Iana;
                return timezoneData.Iana;

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                return null;
            }
        }
        
        async function getRecordData(endpoint, id) {
            try {
                const getEndpoint = `${endpoint}/${id}`;
                const response = await fetch(getEndpoint, {
                    method: 'GET',
                    headers: { 'Authorization': authHeader }
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    return null;
                }
            } catch (error) {
                return null;
            }
        }

        async function getRecordDataAndDiscoverArrays(endpoint, id) {
            try {
                const getEndpoint = `${endpoint}/${id}`;
                const response = await fetch(getEndpoint, {
                    method: 'GET',
                    headers: { 'Authorization': authHeader }
                });
                if (response.ok) {
                    const record = await response.json();
                    
                    for (const key in record) {
                        if (Array.isArray(record[key])) {
                            arrayFields.push(key);
                        }
                    }
                    return record;
                } else {
                    return null;
                }
            } catch (error) {
                return null;
            }
        }

        function mergePayloads(basePayload, updatePayload) {
            return { ...basePayload, ...updatePayload };
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) return { headers: [], records: [] };
            const headers = lines[0].split(',').map(header => header.trim());
            const records = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const values = line.split(',').map(value => value.trim());
                const record = {};
                for (let j = 0; j < headers.length; j++) {
                    record[headers[j]] = values[j] || null;
                }
                records.push(record);
            }
            return { headers, records };
        }
        
        function createPayload(record, method, convertLocalToUtcFunc) {
            const payload = {};
            for (const key in record) {
                if (method === 'POST' && key === 'Id') continue;
                if (record[key] !== null && record[key] !== '') {
                    const value = record[key];

                    if (dateFields.includes(key)) {
                        payload[key] = convertLocalToUtcFunc(value);
                    } else if (arrayFields.includes(key)) {
                        payload[key] = value.includes(';') ? value.split(';') : [value];
                    } else if (!isNaN(value) && value.trim() !== '') {
                        payload[key] = parseFloat(value);
                    } else if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
                        payload[key] = value.toLowerCase() === 'true';
                    } else {
                        payload[key] = value;
                    }
                }
            }
            return payload;
        }

        async function getTemplate() {
            if (!isAuthenticated) {
                log('Error: Please authenticate before getting a template.', 'error');
                return;
            }

            const recordTypeSelect = document.getElementById('recordType');
            const apiEndpoint = recordTypeSelect.value === 'custom' ? document.getElementById('apiEndpoint').value : recordTypeSelect.value;
            
            if (!apiEndpoint || apiEndpoint === '') {
                log('Error: Please select or enter an API endpoint before getting a template.', 'error');
                return;
            }

            log('Fetching sample record to create CSV template...', 'info');
            try {
                // Fetch a list of records to get a sample
                const response = await fetch(apiEndpoint, {
                    method: 'GET',
                    headers: { 'Authorization': authHeader }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to fetch records. Status: ${response.status}. Message: ${errorText}`);
                }

                const data = await response.json();
                let sampleRecord = null;
                if (data.Records && data.Records.length > 0) {
                    sampleRecord = data.Records[0];
                } else if (data.length > 0) {
                    // Handle cases where the response is a direct array of objects
                    sampleRecord = data[0];
                } else {
                    log('No records found at this endpoint to generate a template. The API may require specific query parameters.', 'error');
                    return;
                }

                // Exclude some fields that aren't typically updated via CSV
                const excludedFields = ['CreatedOn', 'UpdatedOn'];
                const headers = Object.keys(sampleRecord).filter(key => !excludedFields.includes(key));
                
                // Get the values for the first record and format for CSV
                const values = headers.map(header => {
                    let value = sampleRecord[header];
                    if (value === null || value === undefined) {
                        return '';
                    }
                    if (Array.isArray(value)) {
                        return value.join(';');
                    }
                    if (typeof value === 'object') {
                        // Stringify complex objects
                        value = JSON.stringify(value);
                    }
                    // Wrap value in quotes if it contains commas
                    if (typeof value === 'string' && value.includes(',')) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });

                const csvString = `${headers.join(',')}\n${values.join(',')}`;
                const blob = new Blob([csvString], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'api_template.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                log('CSV template generated and downloaded successfully.', 'success');

            } catch (error) {
                log(`Error creating template: ${error.message}`, 'error');
            }
        }

        function downloadResults(records, fileName) {
            if (records.length === 0) return;

            // Get all unique headers from all records
            const allHeaders = new Set();
            records.forEach(record => {
                Object.keys(record).forEach(key => allHeaders.add(key));
            });

            const headerArray = Array.from(allHeaders).sort();
            const csvRows = [headerArray.join(',')];

            for (const record of records) {
                const row = headerArray.map(header => {
                    let value = record[header] || '';
                    if (Array.isArray(value)) {
                        value = value.join(';');
                    }
                    if (typeof value === 'object') {
                        value = JSON.stringify(value);
                    }
                    // Escape double quotes and enclose in quotes if needed
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csvRows.push(row.join(','));
            }

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function startUpdate() {
            if (!isAuthenticated) {
                log('Error: Please authenticate first.', 'error');
                return;
            }

            const recordTypeSelect = document.getElementById('recordType');
            const csvFile = document.getElementById('csvFile').files[0];
            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            const getTemplateButton = document.getElementById('getTemplateButton');
            
            const apiEndpoint = recordTypeSelect.value === 'custom' ? document.getElementById('apiEndpoint').value : recordTypeSelect.value;
            const httpMethod = document.getElementById('httpMethod').value;
            isGetOperation = (httpMethod === 'GET');

            if (!apiEndpoint) {
                log('Error: Please enter an API Endpoint URL.', 'error');
                endProcessing();
                return;
            }
            if (!csvFile) {
                log('Error: Please upload a CSV file.', 'error');
                endProcessing();
                return;
            }

            log(`Processing started with method ${httpMethod}...`, 'info');
            startButton.disabled = true;
            if(getTemplateButton) getTemplateButton.disabled = true;
            stopButton.style.display = 'inline-block';
            isProcessing = true;
            processedCount = 0; // Reset progress counter
            fetchedRecords = []; // Reset fetched records for GET operation
            failedRecords = []; // Reset failed records

            const reader = new FileReader();
            reader.onload = async function(event) {
                const csvText = event.target.result;
                const { headers, records } = parseCSV(csvText);
                allRecords = records;
                
                if (allRecords.length === 0) {
                    log('Error: CSV file is empty or could not be parsed.', 'error');
                    endProcessing();
                    return;
                }
                
                if (!headers.includes('Id') && httpMethod !== 'POST') {
                    log('Error: CSV file is missing the required "Id" column. Aborting.', 'error');
                    endProcessing();
                    return;
                }
                
                // Only perform array discovery for PUT requests
                if (httpMethod === 'PUT') {
                    const recordToDiscover = allRecords[0];
                    if (recordToDiscover && recordToDiscover['Id']) {
                        log(`Performing initial GET request to discover array fields on ID ${recordToDiscover['Id']}...`, 'info');
                        await getRecordDataAndDiscoverArrays(apiEndpoint, recordToDiscover['Id']);
                        if (arrayFields.length > 0) {
                            log(`Discovered array fields: ${arrayFields.join(', ')}`, 'info');
                        } else {
                            log('No array fields discovered in the sample record.', 'info');
                        }
                    }
                }
                
                log(`Starting batch process for ${allRecords.length} records.`, 'info');
                await processRecords(allRecords);
                endProcessing();
            };
            reader.readAsText(csvFile);
        }

        async function processRecords(recordsToProcess) {
            const apiEndpoint = document.getElementById('recordType').value === 'custom' ? document.getElementById('apiEndpoint').value : document.getElementById('recordType').value;
            const httpMethod = document.getElementById('httpMethod').value;
            const totalRecords = allRecords.length;
            const proceedButton = document.getElementById('proceedButton');
            const stopButton = document.getElementById('stopButton');

            for (const record of recordsToProcess) {
                if (!isProcessing) break;
                
                const recordId = record['Id'];
                if (!recordId && httpMethod !== 'POST') {
                     log(`Error: Skipping record as 'Id' column is required for this method.`, 'error');
                     failedRecords.push({ ...record, ErrorMessage: 'Id is required for this method.' });
                     processedCount++;
                     updateProgressBar(processedCount, totalRecords);
                     continue;
                }

                let targetEndpoint = apiEndpoint;
                let fetchOptions = {};
                
                if (httpMethod === 'GET' || httpMethod === 'DELETE') {
                    targetEndpoint = `${apiEndpoint}/${recordId}`;
                    fetchOptions = { method: httpMethod, headers: { 'Authorization': authHeader } };
                } else if (httpMethod === 'PUT' || httpMethod === 'POST') {
                    if (!record['LocationId']) {
                        log(`Error: Skipping record as 'LocationId' is required for this method.`, 'error');
                        failedRecords.push({ ...record, ErrorMessage: 'LocationId is required for this method.' });
                        processedCount++;
                        updateProgressBar(processedCount, totalRecords);
                        continue;
                    }
                    
                    log(`Processing record for LocationId: ${record.LocationId || 'N/A'}...`, 'info');
                    let businessTimeZoneId;
                    if (businessTimeZoneCache[record.LocationId]) {
                        businessTimeZoneId = businessTimeZoneCache[record.LocationId];
                    } else {
                        businessTimeZoneId = await getBusinessTimeZoneByLocation(record.LocationId);
                        if (!businessTimeZoneId) {
                            log(`Failed to retrieve timezone for Location ID ${record.LocationId}. Skipping this record.`, 'error');
                            failedRecords.push({ ...record, ErrorMessage: 'Failed to retrieve timezone for this location.' });
                            processedCount++;
                            updateProgressBar(processedCount, totalRecords);
                            continue;
                        }
                    }

                    const convertLocalToUtc = (dateString) => {
                        const { DateTime } = luxon;
                        const format = 'yyyy-MM-dd HH:mm';
                        if (DateTime.fromISO(dateString).isValid) { return dateString; }
                        const localDateTime = DateTime.fromFormat(dateString, format, { zone: businessTimeZoneId });
                        if (localDateTime.isValid) {
                            const utcDateTime = localDateTime.toUTC().toISO({ includeOffset: false, suppressMilliseconds: true });
                            return utcDateTime;
                        }
                        return dateString;
                    };

                    let payload = {};
                    if (httpMethod === 'PUT') {
                        log(`Fetching existing record for ID ${recordId}...`, 'info');
                        const existingRecord = await getRecordData(apiEndpoint, recordId);
                        if (!existingRecord) {
                            const errorMsg = `Could not fetch existing record for ID ${recordId}.`;
                            log(`Error: ${errorMsg}`, 'error');
                            failedRecords.push({ ...record, ErrorMessage: errorMsg });
                            processedCount++;
                            updateProgressBar(processedCount, totalRecords);
                            continue;
                        }
                        payload = mergePayloads(existingRecord, createPayload(record, httpMethod, convertLocalToUtc));
                    } else { // POST
                        payload = createPayload(record, httpMethod, convertLocalToUtc);
                    }
                    
                    fetchOptions = {
                        method: httpMethod,
                        headers: { 'Content-Type': 'application/json', 'Authorization': authHeader },
                        body: JSON.stringify(payload)
                    };
                }

                try {
                    log(`Sending request to: ${targetEndpoint}`, 'info');
                    const response = await fetch(targetEndpoint, fetchOptions);

                    if (response.ok) {
                        if (httpMethod === 'GET') {
                            const data = await response.json();
                            fetchedRecords.push(data);
                            log(`Success: Details for Record ID ${recordId} fetched.`, 'success');
                        } else {
                            log(`Success: Record ID ${recordId || 'new record'} processed successfully with method ${httpMethod}.`, 'success');
                        }
                    } else {
                        const errorText = await response.text();
                        log(`Error: Failed to process Record ID ${recordId || 'new record'} with method ${httpMethod}. Status: ${response.status}. Message: ${errorText}`, 'error');
                        failedRecords.push({ ...record, ErrorMessage: errorText });
                    }
                } catch (error) {
                    const errorMsg = error.message || 'Network error.';
                    log(`Error: Failed to send request for Record ID ${recordId || 'new record'}. Message: ${errorMsg}`, 'error');
                    failedRecords.push({ ...record, ErrorMessage: errorMsg });
                }
                
                processedCount++;
                updateProgressBar(processedCount, totalRecords);

                if (processedCount === 1 && isProcessing && !isGetOperation) {
                    isProcessing = false;
                    log('First record processed. Please check the Nexudus Admin Panel to confirm the changes before proceeding. Click "Proceed" to continue or "Stop Processing" to cancel the rest of the batch.', 'info');
                    
                    proceedButton.style.display = 'inline-block';
                    stopButton.style.display = 'inline-block';

                    await new Promise(resolve => {
                        proceedResolver = resolve;
                        proceedButton.onclick = () => {
                            isProcessing = true;
                            proceedButton.style.display = 'none';
                            log('Proceeding with the rest of the records...', 'info');
                            resolve();
                        };
                        stopButton.onclick = () => {
                            isProcessing = false;
                            proceedButton.style.display = 'none';
                            stopButton.style.display = 'none';
                            log('Processing stopped by user. No more records will be processed.', 'error');
                            resolve();
                        };
                    });

                    if (!isProcessing) break;
                }

                if (isProcessing) {
                    await new Promise(resolve => setTimeout(resolve, requestDelay));
                }
            }
        }
        
        function endProcessing() {
            log('Processing complete!', 'info');
            isProcessing = false;
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').style.display = 'none';
            document.getElementById('proceedButton').style.display = 'none';
            document.getElementById('downloadButton').style.display = 'block';

            const downloadButton = document.getElementById('downloadButton');
            
            if (isGetOperation) {
                if (fetchedRecords.length > 0) {
                    downloadButton.textContent = 'Download Results';
                    downloadButton.onclick = () => downloadResults(fetchedRecords, 'api_get_results.csv');
                    log(`\nSuccessfully retrieved details for ${fetchedRecords.length} record(s). Click "Download Results" to get the details.`, 'success');
                } else {
                    downloadButton.style.display = 'none';
                    log('\nNo records were successfully retrieved.', 'error');
                }
                if (failedRecords.length > 0) {
                     log(`\n${failedRecords.length} record(s) failed to retrieve. Check the log for details.`, 'error');
                     downloadButton.textContent += ' & Failed';
                     const originalOnClick = downloadButton.onclick;
                     if(originalOnClick) {
                         downloadButton.onclick = () => {
                             originalOnClick();
                             downloadResults(failedRecords.map(r => ({ ...r, FailedReason: r.ErrorMessage })), 'failed_get_requests.csv');
                         };
                     } else {
                         downloadButton.textContent = 'Download Failed Records';
                         downloadButton.onclick = () => downloadResults(failedRecords.map(r => ({ ...r, FailedReason: r.ErrorMessage })), 'failed_get_requests.csv');
                     }
                }
            } else { // PUT, POST, DELETE
                downloadButton.textContent = 'Download Failed Records';
                downloadButton.onclick = () => downloadResults(failedRecords.map(r => ({ ...r, FailedReason: r.ErrorMessage })), 'failed_api_updates.csv');
                if (failedRecords.length > 0) {
                    log(`\n${failedRecords.length} record(s) failed to update. Click "Download Failed Records" to get the details.`, 'error');
                } else {
                    downloadButton.style.display = 'none';
                }
            }
        }
        // Initial call to set up the fields based on the default radio button selection
        window.onload = toggleAuthFields;
    </script>
</body>
</html>
